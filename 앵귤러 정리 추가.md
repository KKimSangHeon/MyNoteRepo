# AngularJS

### 디렉티브
HTML 태그나 어트리뷰트의 기능을 새롭게 만드는 개념. 애플리케이션의 요구 사항에 맞게 HTML 태그를 확장할 수 있다.

### ng-app
<div>에 ng-app 어트리뷰트를 추가하면 그 <div>만 AngularJS의 영향을 받는다.

### 바인딩
뷰와 모델이 서로를 갱신하는것. AngularJS는 모델이 갱신될 때마다 전체 애플리케이션에 영향을 미치는 $digest 함수를 실행하면서 데이터 바인딩을 점검하고 DOM 객체의 값을 갱신한다.

### socpe
모델의 값은 $scope라는 스코프 안에 선언되며 AngularJS에서는 이 스코프를 여러 계층으로 구성한다.

# Angular

### NgModule
모듈은 클래스에 @NgModule 어노테이션을 붙여서 지정하고 이 어노테이션 안에서 모듈 내용을 설정한다.

### SystemJS 모듈로더
JS는 script 태그 안에서 로드하고 실행하지만 Angular도 이 방법을 사용할 수 있지만 SystemJS 라이브러리를 사용해서 불러오는것을 권장한다.
why? 스크립트 태그를 삭제하지 않으면 이를 불러오려고 하고 불필요한 부하 발생 , 스크립트 태그의 실행순서를 보장하지 않기 때문에 문제가 될 수 있다. 

environment.ts 파일 -> 빌드를 위한 개발환경 설정 정보들

## 빌드명령어
Angular-CLI로 만들어진 프로젝트의 코드는 타입스크립트 기반이기 때문에 빌드를 통해 브라우저에서 동작 가능한 자바스크립트로 변환해야 한다.

ng build 

프로덕션용 빌드 명령어
ng build --prod 

# 타입스크립트

## 1.let을 이용한 변수선언
ES 5 이하에서 호이스팅 문제가 발생하므로 이를 해결하기 위해 ES6의 좋은 특징인 let 선언자를 이용

타입스크립트는 변수명 뒤에 타입을 명시해야 한다. 타입스크립트를 타입 언어라고 하는 이유는 이와 같은 이유이다.
let 변수명 : 타입;
let emotion2:string="happy";

## 배열타입
#### 배열정의 형태1
let fruits: string[] = ["a","b"];


let fruits2: string[] = [];
fruits2.push("a");

#### 배열정의 형태2
let num:Array<number> = [1,2,3];


## 유니언 타입 56p
유니언 타입은 2개 이상으로 입력된 타입에 대해 하나의 타입으로 정의하는것. 메소드의 파라미터로 사용가능.
var unionX: string | number = 1;
console.log(typeof unionX, unionX); // number 1 출력


## 문자열 표현 58p
+와 \n을 써서 줄바꿈이 가능하지만 다음과 같이 가능하다.
let w: string ="world";
let one: number = 1;
function hi(){
    return "hi";
}

let hello_message: string =`
hello ${w}
1 + ${one} = ${1+1}
${hi()}
`
console.log(hello_message);


## 디스트럭처링 지원 60p
ES6에 포함된 특징으로 배열이나 객체에서 데이터를 선택적으로 추출할 수 있는 자바스크립트 할당식이다.
var params2 = ['happy 동물원', 100];
let[m_name2, m_num2] = params2;


## 컴포넌트
앵귤러에서 화면하는 구성하는 중요한 구성요소이다.

### 웹 컴포넌트
HTML , CSS, 자바스크립트를 하나의 단위로 묶어주는 기술이다. 웹 컴포넌트 기술은 하나의 기능이 아니라 여러가지 기술들이 합쳐져 하나의 웹 컴포넌트를 구성
 웹 컴포넌트는 앵귤러2 컴포넌트의 기반기술이다 앵귤러 2 컴포넌트는 웹 컴포넌트의 기술요소를 기반으로 하므로 웹 컴포넌트를 이해하면 앵귤러 컴포넌트를 이해하는 데 도움된다.
1. HTML 템플릿
2. 템플릿 호출
3. 쉐도우 DOM
4. 커스텀 엘리먼트



### 중첩컴포넌트 85p
부모 컴포넌트가 여러 자식컴포넌트를 포함하는 경우

### 컴포넌트 트리 86p
평면적으로 나열된 컴포넌트가 어떤 포함 관계를 가지는지 알수있게 해줌

### 컴포넌트 기반 개발 87p
컴포넌트를 개발의 중심에 두고 개발하는것.

## 컴포넌트 89p
컴포넌트 내부는 크게 import 영역, @Component 장식자(selector, template, styles로 구성됨), 컴포넌트 클래스 영역으로 나뉜다.

## 부모가 자식한테 값 전달
부모가 속성바인드를 통해 값을 전달하면 자식이 값을 받는 방법은 2가지가 있다.

### @input 장식자 99p
외부에서 전달된 값을 받기 위해 사용하는 장식자


### inputs 102p
부모가 name1, name2 속성으로 어떠한 값을 전달하면 자식은 @Component장식자 안에 inputs:['name1','name2']로 값을 받을 수 있다. 자식의 클래스에서도 name1, name2를 지정해줘야함

## 자식이 부모한테 값 전달 103p
@Output 장식자로 선언한 변수를 EventEmitter로 초기화한다. 그리고 부모에게 보낼 시점이 되면 emit()메소드를 사용해 부모로 이벤트를 전달한다.

### @ViewChild 장식자 107p
화면 DOM에 접근해 첫 번째로 위치한 지시자의 내부 상태(지시자의 속성값)나 정보(컴포넌트 지시자의 경우 내부 메서드)를 가져온다

### @ViewChildren 장식자 109p
@ViewChild는 하나의 엘리먼트 상태를 갖고왔지만 @ViewChildren 장식자는 여러 지시자의 상태를 한번에 취할 수 있다.

### @ContentChild 장식자 112p
콘텐츠 DOM을 탐색해 지시자 엘리먼트의 상태를 QueryList에 담는 역할을 한다.

### @ContentChildren 장식자 114p
컴포넌트 내부에 위치한 엘리먼트나 지시자에 정보를 담고 있는 쿼리리스트를 얻는다.

### 쉐도우 DOM의 선택자 118p
그냥 styles:['span{font-style}'] 이런식으로 하면 해당 컴포넌트의 span만 적용된다. 이를 범위를 넓히거나 좁힐때 사용하는것이 쉐도우 DOM의 선택자이다.
1.:host 선택자
2.:host-context 선택자
3.:deep 선택자






